var deploys = module.exports = {};

var mods = deploys.mods = {
    deasync: require('deasync'),
    shell: require('shelljs'),
    yaml: require('js-yaml'),
    metaproxy: require('./metaproxy'),
    utils: require('./utils')
};

var R = require('ramda');
var _ = require('lodash');

mods.shell.config.fatal = true;

// All files generated by shasoco will be stored in the folowing directory.
var SHASOCO_PROJ_DIR = "/var/lib/shasoco/deploys"; // process.env.HOME + "/.shasoco/deploys";

// The source docker-compose directory.
//
// Note that once deployed, a domain will maintain a copy of the compose
// directory, in SHASOCO_PROJ_DIR, with templates compiled.
//
// This allows multiple projects to run on the same machin with multiple
// shasoco versions.
var COMPOSE_DIR = __dirname + '/../compose';

// Return the path for a per-project (or domain) file.
//
// Hereby, "project" and "deploys" are interchangeable words,
// there can be just 1 project per domain and 1 domain per project.
var projectDir = deploys.path = function(name) {
    return SHASOCO_PROJ_DIR + "/" + name;
};

// Return the path the project's configuration file.
var projectFile = deploys.configPath = function(name) {
    return projectDir(name) + "/config.yml";
};

// Returns true if the given domain name exists on the host.
var exists = deploys.exists = function(name) {
    return mods.shell.test('-f', projectFile(name));
};

// Return LDAP-compatible DC description of a domain.
// eg. "fovea.cc" is converted to "dc=fovea,dc=cc"
var makeDC = function(name) {
    return name
        .split(".")
        .map(mods.utils.addPrefix("dc="))
        .join(",");
};

// Return input data to feed the templates
//
// It consists of the full configuration file, plus some computed values.
var compileData = function(conf) {
    return _.extend({
        ldapdc: makeDC(conf.domain),
        httpHost: conf.domain + (conf.httpPort== '80' ? '' : (":" + conf.httpPort)),
        httpsHost: conf.domain + (conf.httpsPort == '443' ? '' : (":" + conf.httpsPort))
    }, conf);
};

// Compiles from a string,
// stores the compiled version in the project directory.
// The template is fed with data from `compileData`.
var compileWith = R.curry(function(conf, filename, content) {
    mods.utils.saveTo(projectDir(conf.id) + '/' + filename,
                      _.template(content)(compileData(conf)));
});

// Compiles a file located in the source docker-compose directory,
// stores the compiled version in the project directory.
// The template is fed with data from `compileData`.
var compile = R.curry(function(conf, filename) {
    compileWith(conf, filename, mods.shell.cat(COMPOSE_DIR + '/' + filename));
});

// Generate a new domain configuration directory.
//
// All files from source docker-compose directory are compiled and
// copied to the newly-created project directory.
var create = deploys.create = function(id, options) {
    var conf = _.extend({ id: id }, options, {
        salt: mods.utils.genSalt(),
        rootpassword: mods.utils.genPassword(),
        adminpassword: mods.utils.genPassword(),
        vaultpath: require('path').dirname(SHASOCO_PROJ_DIR) + "/vault." + options.domain,
        docpath: require('path').dirname(SHASOCO_PROJ_DIR) + "/doc." + options.domain,
        docbranch: 'master'
    });
    save(conf);
    return conf;
};

// Compiles all files from docker-compose directory,
// store the output into the project directory.
var prepare = deploys.prepare = function(conf, services) {

    // put together the docker-compose file
    var dockerComposeData = '';
    services.forEach(function(service) {
        if (service.composeFile) {
            dockerComposeData += mods.shell.cat(COMPOSE_DIR + '/' + service.composeFile);
        }
    });
    compileWith(conf, 'docker-compose.yml', dockerComposeData);

    // compile other files required by the services
    services.forEach(function(service) {
        if (service.otherFiles)
            service.otherFiles.forEach(compile(conf));
    });
};

// XXX Is a project upgrade only about re-compiling all files?
var upgrade = deploys.upgrade = prepare;

// Saves the domain configuration into the project's config.yml file
var save = deploys.save = function(conf) {
    conf = _.extend({}, conf);
    delete conf.status; // status is computed, no need to save.
    mods.shell.mkdir('-p', projectDir(conf.id));
    mods.yaml.safeDump(conf).to(projectFile(conf.id));
};

// Return the docker-compose name of a domain
var composeName = deploys.composeName = function(name) {
    return name.replace(/\./g, '');
};

// Return true if a domain is running
var isUp = function(name) {
    var ps = mods.shell.exec('docker ps', {silent:true});
    return ps.output.indexOf(" " + composeName(name) + "_") >= 0;
};

// Return true if a domain is not running
var isStopped = function(name) {
    return mods.shell.exec('docker ps -a', {silent:true}).output.indexOf(" " + composeName(name) + "_") >= 0;
};

// Load a project's domain configuration, extended with some dynamic attributes.
var load = deploys.load = function(name) {
    var p = mods.shell.cat(projectFile(name));
    var conf = mods.yaml.safeLoad(p);
    if (isUp(name))
        conf.status = 'UP';
    else
        conf.status = 'DOWN';

    try {
        var active = mods.deasync(mods.metaproxy.isActive)(conf);
        if (active) {
            bindings = active.HostConfig.PortBindings;
            conf.ports = [ "22", "80", "443" ].map(function(p) {
                return bindings[p + "/tcp"][0].HostPort.split("/")[0];
            }).join(",");
        }
    }
    catch (e) {}
    return conf;
};

// Same as load, but exit the app with an error when things go wrong.
var safeLoad = deploys.safeLoad = function(id, cb) {
    if (!id)
        return mods.utils.error(cb, "deploy missing");
    if (!deploys.exists(id))
        return mods.utils.error(cb, "deploy doesn't exist");
    var conf = deploys.load(id);
    if (!conf)
        return mods.utils.error(cb, "failed to load the deploy");
    return conf;
};

// Remove a project's directory.
var remove = deploys.remove = function(conf) {
    mods.shell.rm('-rf', projectDir(conf.id));
    conf.status = 'REMOVED';
};

// Return the list of all projects
var list = deploys.list = function() {
    mods.shell.mkdir('-p', projectDir(''));
    return mods.shell.ls(projectDir('')).map(load);
};

// Run docker-compose for the given project
var compose = deploys.compose = R.curry(function(conf, args) {
    var cwd = mods.shell.pwd();
    mods.shell.cd(projectDir(conf.id));
    var ret = mods.shell.exec('docker-compose ' + args);
    mods.shell.cd(cwd);
    return ret;
});

var dockerExec = deploys.dockerExec = R.curry(function(conf, service, cmd) {
    return mods.shell.exec('docker exec -it ' + composeName(conf.id) + "_" + service + "_1 " + cmd);
});
